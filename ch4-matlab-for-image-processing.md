#### **1.先聊聊基于模型的设计**

可以先看看知乎这篇文章《[基于模型设计——电力电子的利器](https://zhuanlan.zhihu.com/p/23149544)》

最开始我们做小的系统，自己想怎么码就怎么码，想怎么命名就怎么命名，因为系统小，不管怎么折腾复杂度都可控，但是随着代码量的增加，我们开始切分函数，然后切分模块，（参见ch1），这时候我们开始考虑模块化设计，考虑模块的封装与耦合，尽量高内聚低耦合，随着系统复杂度进一步增加，我们开始几个人协同开发，考虑分层，考虑应用层，系统层，驱动层，数据服务是不是要独立出来，通讯是不是要单独出来，是裸跑，RTOS还是Linux，接口如何划分和设计，这时候就开始系统级地去进行软件设计，实现尽可能正交的系统，减少冗余代码。随着系统进一步复杂，代码量和复杂度都在不断攀升，这时候又有什么应对措施呢？？

还有一个问题，我们始终避免不了，就是嵌入式系统的测试与验证，如果按照瀑布模型走的话，等所有代码都完成了，再进行验证测试的话，如果一旦出现问题，再返工重新设计，那不拖延项目才怪呢，所以我们尽可能的将验证测试提前，要早期发现错误，那风险和随时也就越低。在这里我们想尝试喷泉模型，在每一个阶段都能进行验证测试，但是嵌入式系统软件和一般软件系统不太一样，因为要与实物配合才能进行测试验证。就卡在这里，有没有什么好的解决方案呢？

其实，嵌入式系统里，有一部分是纯逻辑与控制算法，这是系统的核心，按理说大量的精力应该放在这里，但是实际中我们更多的时间被接口，驱动，RTOS所累，最后对控制模型反而有点心有余而力不足。那是不是有让我们更专注于模型设计与控制算法的设计方法呢，以此提高我们的工作效率，更专注于核心。

正是基于以上几点，MBD（Model Based Design-基于模型的设计）闪亮登场，于是Matlab/Simulink进入了我们的工具箱，不过这里面分三种玩法：

* 土鳖的玩法：Simulink搭建模型与算法，验证测试通过后，然后再徒手实现C代码
* 折中的玩法：利用mexfunction写C的控制算法，Simulink模型配合mex构建的控制算法，仿真验证
* 高级的玩法：Simulink搭建模型与算法，验证测试通过后，自动生成C代码（高级是高级，但是生成的代码没法看）

考虑到代码的移植以及可读性，我们采用的是折中玩法，下面我以智能车的图像处理来简单介绍一下。

**最低效率的方式（比土鳖还土鳖）**

徒手写图像处理的C代码下载到车里，放到赛道上跑两圈，如果好了一把成，但如果出了问题，只能抱着笔记本，连着J-Link调试，趴在那里，一点点查找程序错误，这中间哪怕一个很小的bug问题，都会消耗极大的体力和脑力，因为不受控的因素太多了。

**改进版的方式（土鳖玩法）**

先大量采集赛道图片，覆盖90%以上路况的情况，然后在Matlab里对这些图片进行处理，实现图像处理算法，等验证通过后，再把Matlab徒手翻译为C代码，然后上赛道测试，依然会出现部分bug，但是80%的低级的原则性的bug在Matlab验证阶段已经被消灭了。

**目前要做的方式（折中玩法）**

在改进版中，matlab中验证的是matlab代码，车上跑的是C代码，由于这中间存在人工转化的过程，意味着依然可能会引入未知的错误。为何不直接在matlab里直接验证我的C代码呢？对了，这就是交叉编译，在matlab里直接调用C语言，OK，这样就能保证最终车里跑的代码，是在matlab里最终验证通过的了，Yeah。

#### 2**.工作环境搭建**

Matlab 的软件版本推荐2011a（我比较钟爱老版本，哈哈，因为占地小）

C&C++编译器，推荐VS2010

第一步，先装好Matlab 2011a和VS2010（大家度娘解决吧）。

第二步，在Matlab下配置C&C++交叉编译器。

1.在matlab的工作台中输入mex–setup命令（mex就是matlab支持交叉编译的工具）

![](/assets/EmbeddedSystem_S4_P0.png)

2.回车后，会输出一段话，最后是“Would you  like mex to locate installed compilers\[y\]/n”是问你确定要为mex配置编译器？请输入y表示确定。

![](/assets/EmbeddedSystem_S4_P1.png)

3.此时，会显示matlab搜索到已经安装好的VS2010，你要在Compiler：后面输入相应的选择序号1，回车.

![](/assets/EmbeddedSystem_S4_P2.png)

4.在上图里，显示了你配置的编译器，最后需要输入y确认此配置，这样就OK了。

![](/assets/EmbeddedSystem_S4_P3.png)

#### 3.**如何编译C代码**

比如我们实现最简单的y=a+b这样一个加法操作。

用matlab的函数function如何做呢？看下面：

```
function y=add(a,b)
    y=a+b;
```

将上面的代码保存为add.m，这样在matlab的工作台就可以调用这个函数了，比如：

![](/assets/EmbeddedSystem_S4_P4.png)

那这样一个简单的加法，我用C语言怎么实现呢？也很简单

```
double  add(double  a, double  b)
{
    return a+b;
}
```

既然我实现了C语言函数，那在matlab里怎么样调用这个C函数呢？这时候，我们前面配置好的mex交叉编译工具就上场了。

看下面这段代码，看不懂没关系，后面会一一解释的。

```
void mexFunction ( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] )
{
    double *Y;
    double A, B;
 
    //输入接口绑定
    A = *(mxGetPr(prhs[0]));
    B = *(mxGetPr(prhs[1]));
    
    //输出接口绑定
    plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL); 
    Y = mxGetPr(plhs[0]);
    
    //做你该做的事
    *Y = add(A, B);
}
```

将上面的这段代码，创建为了new\_add.c，然后在工作台上输入mex new\_add.c命令，编译无错，就可以使用了。

![](/assets/EmbeddedSystem_S4_P5.png)

  


我们到底做了什么？其实，你只是把这个函数需要的两个参数a和b从matlab倒腾到C语言里面，进行了相应运算之后，再把输出结果从C语言里面倒腾到Matlab里而已。

不要怕麻烦，为了不熬夜调车，为了不做码农，刚开始势必会麻烦一点，等熟练了就好了，等你的代码到2000行或者更多的时候，你依然可以有时间优哉游哉地玩耍。

其实Matlab的大侠们，已经给这个倒腾过程，建立了一个专门的接口函数叫mexFunction，这个函数有四个参数分别为：

```
int nlhs                  输出变量个数
mxArray *plhs[]           输出变量指针数组
int nrhs                  输入变量个数
const mxArray *prhs[]     输入变量的指针数组
```

  
比如看我们上面的例子，当我调用new\_add\(3,4\)时，

```
int nlhs                  输出变量个数为1
mxArray *plhs[]           输出变量指针数组，plhs[0]对应求和结果y的变量地址
int nrhs                  输入变量个数为2
const mxArray *prhs[]     输入变量的指针数组有两个，prhs[0]为参数a=3对应的地址，prhs[1]为参数b=4对应的地址。
//接下来就是把输入的两个参数读取到C变量里暂存，mxGetPr是获取数组地址，*就是获取地址里的内容。
//输入接口绑定
A = *(mxGetPr(prhs[0]));
B = *(mxGetPr(prhs[1]));

//再下面是输出接口的绑定，输出未分配存储空间，所以必须先申请存储空间，用mxCreateDoubleMatrix，然后用C指针变量指向这个地址。
//输出接口绑定
plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL); 
Y = mxGetPr(plhs[0]);

//然后就是你要做的操作，调用add，

```



最后做实现加操作想做的事，调用函数add实现加操作。





